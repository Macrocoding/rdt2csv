/* Generated by Macrocoder - do not edit */
#define _CRT_SECURE_NO_WARNINGS
#include "md380_file.h"
#include <stdio.h>
#include <assert.h>
#include <errno.h>

/* Function that opens a file and saves all the records of 'ChannelInformation'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFile_ChannelInformation (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	FILE* f = NULL;
	unsigned i;
	
	assert (errorMessage != NULL);
	assert ((*errorMessage) == NULL);
	
	f = fopen (fileName, "wb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for writing (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}

	ret = encodeCSVHeader_ChannelInformation (separator, md380_FILEWriteBinaryFunc, f);
	if (ret != CSVRET_OK) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error writing CSV header when saving %s (%s)\n", fileName, md380_CsvRetToString (ret));
		goto exitFunc;
	}

	for (i=0; i<container->ChannelInformation_COUNT; i++) {
		ret = encodeCSVRecord_ChannelInformation (i, separator, md380_FILEWriteBinaryFunc, f, container->ChannelInformation+i, errorMessage);
		if (ret != CSVRET_OK) break;
	}


	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and reads all the records of 'ChannelInformation'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFile_ChannelInformation (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
{
	int ret;
	unsigned i, j, numberOfColumns;
	unsigned fieldsMap[FIELDS_ChannelInformation];
	FILE* f = NULL;
	T_ChannelInformation record;
	

	/* Clear the container */
	container->ChannelInformation_COUNT = 0;

	
	/* Open the file for reading */
	f = fopen (fileName, "rb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for reading (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}
	
	/* Read the titles */
	ret = md380_ReadColumnsMapping (DESC_ChannelInformation, FIELDS_ChannelInformation, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
	if (ret != CSVRET_OK) goto exitFunc;
	
	/* Read the records */
	ret = CSVRET_EOF;
	for (i=0;;i++) {
		memset (&record, 0, sizeof(record));
	
		/* Read fields within records */
		for (j=0; ; j++) {
			if (j >= numberOfColumns) {
				(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
				sprintf ((*errorMessage), "In file '%s', line %d, too many columns\n", fileName, i+2);
				ret = MD380ERR_INVALID_CSV_FORMAT;
				goto exitFunc;
			}
			
			switch (fieldsMap[j]) {
				case 0: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+0, &(record.LoneWorker), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 1: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+1, &(record.Squelch), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 2: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+2, &(record.Autoscan), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 3: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+3, &(record.Bandwidth), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 4: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+4, &(record.ChannelMode), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 5: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+5, &(record.Colorcode), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 6: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+6, &(record.RepeaterSlot), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 7: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+7, &(record.RxOnly), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 8: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+8, &(record.AllowTalkaround), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 9: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+9, &(record.DataCallConf), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 10: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+10, &(record.PrivateCallConf), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 11: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+11, &(record.Privacy), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 12: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+12, &(record.PrivacyNo), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 13: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+13, &(record.DisplayPttId), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 14: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+14, &(record.CompressedUdpHdr), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 15: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+15, &(record.EmergencyAlarmAck), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 16: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+16, &(record.RxRefFrequency), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 17: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+17, &(record.AdmintCriteria), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 18: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+18, &(record.Power), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 19: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+19, &(record.Vox), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 20: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+20, &(record.QtReverse), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 21: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+21, &(record.ReverseBurst), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 22: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+22, &(record.TxRefFrequency), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 23: ret = md380_ReadFieldReferenceNumeric (DESC_ChannelInformation+23, &(record.ContactName), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 24: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+24, &(record.Tot), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 25: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+25, &(record.TotRekeyDelay), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 26: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+26, &(record.EmergencySystem), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 27: ret = md380_ReadFieldReferenceUnicode (DESC_ChannelInformation+27, &(record.ScanList), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 28: ret = md380_ReadFieldReferenceUnicode (DESC_ChannelInformation+28, &(record.GroupList), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 29: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+29, &(record.Decode18), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 30: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+30, &(record.RxFrequency), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 31: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+31, &(record.TxFrequency), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 32: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+32, &(record.CtcssDcsDecode), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 33: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+33, &(record.CtcssDcsEncode), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 34: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+34, &(record.TxSignalingSyst), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 35: ret = md380_ReadFieldNumeric (DESC_ChannelInformation+35, &(record.RxSignalingSyst), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 36: ret = md380_ReadFieldUnicode (DESC_ChannelInformation+36, record.Name, 16, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				default: assert (0);
			}
			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
			if (ret != CSVRET_OK) goto exitFunc;
		}
		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
		if (j+1 < numberOfColumns) {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, missing columns\n", fileName, i+2);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* Abort if an unexpected result has been detected */
		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
		
		/* Add the record if in range */
		if (i < COUNT_ChannelInformation) {
			memcpy (container->ChannelInformation+i, &record, sizeof (record));
			container->ChannelInformation_COUNT = i+1;
		}
		else {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, too many lines (MAX=%d)\n", fileName, i+2, COUNT_ChannelInformation);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* If the last field included an EOF, we are done */
		if (ret == CSVRET_EOF) break;
	}
	ret = CSVRET_OK;
	
	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and saves all the records of 'DigitalContact'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFile_DigitalContact (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	FILE* f = NULL;
	unsigned i;
	
	assert (errorMessage != NULL);
	assert ((*errorMessage) == NULL);
	
	f = fopen (fileName, "wb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+142);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for writing (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}

	ret = encodeCSVHeader_DigitalContact (separator, md380_FILEWriteBinaryFunc, f);
	if (ret != CSVRET_OK) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+142);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error writing CSV header when saving %s (%s)\n", fileName, md380_CsvRetToString (ret));
		goto exitFunc;
	}

	for (i=0; i<container->DigitalContact_COUNT; i++) {
		ret = encodeCSVRecord_DigitalContact (i, separator, md380_FILEWriteBinaryFunc, f, container->DigitalContact+i, errorMessage);
		if (ret != CSVRET_OK) break;
	}


	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and reads all the records of 'DigitalContact'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFile_DigitalContact (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
{
	int ret;
	unsigned i, j, numberOfColumns;
	unsigned fieldsMap[FIELDS_DigitalContact];
	FILE* f = NULL;
	T_DigitalContact record;
	

	/* Clear the container */
	container->DigitalContact_COUNT = 0;

	
	/* Open the file for reading */
	f = fopen (fileName, "rb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+142);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for reading (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}
	
	/* Read the titles */
	ret = md380_ReadColumnsMapping (DESC_DigitalContact, FIELDS_DigitalContact, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
	if (ret != CSVRET_OK) goto exitFunc;
	
	/* Read the records */
	ret = CSVRET_EOF;
	for (i=0;;i++) {
		memset (&record, 0, sizeof(record));
	
		/* Read fields within records */
		for (j=0; ; j++) {
			if (j >= numberOfColumns) {
				(*errorMessage) = (char*)binAlloc (strlen (fileName)+142);
				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
				sprintf ((*errorMessage), "In file '%s', line %d, too many columns\n", fileName, i+2);
				ret = MD380ERR_INVALID_CSV_FORMAT;
				goto exitFunc;
			}
			
			switch (fieldsMap[j]) {
				case 0: ret = md380_ReadFieldNumeric (DESC_DigitalContact+0, &(record.CallId), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 1: ret = md380_ReadFieldNumeric (DESC_DigitalContact+1, &(record.CallReceiveTone), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 2: ret = md380_ReadFieldNumeric (DESC_DigitalContact+2, &(record.CallType), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 3: ret = md380_ReadFieldUnicode (DESC_DigitalContact+3, record.Name, 16, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				default: assert (0);
			}
			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
			if (ret != CSVRET_OK) goto exitFunc;
		}
		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
		if (j+1 < numberOfColumns) {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+142);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, missing columns\n", fileName, i+2);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* Abort if an unexpected result has been detected */
		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
		
		/* Add the record if in range */
		if (i < COUNT_DigitalContact) {
			memcpy (container->DigitalContact+i, &record, sizeof (record));
			container->DigitalContact_COUNT = i+1;
		}
		else {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+142);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, too many lines (MAX=%d)\n", fileName, i+2, COUNT_DigitalContact);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* If the last field included an EOF, we are done */
		if (ret == CSVRET_EOF) break;
	}
	ret = CSVRET_OK;
	
	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and saves all the records of 'DigitalRxGroupList'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFile_DigitalRxGroupList (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	FILE* f = NULL;
	unsigned i;
	
	assert (errorMessage != NULL);
	assert ((*errorMessage) == NULL);
	
	f = fopen (fileName, "wb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for writing (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}

	ret = encodeCSVHeader_DigitalRxGroupList (separator, md380_FILEWriteBinaryFunc, f);
	if (ret != CSVRET_OK) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error writing CSV header when saving %s (%s)\n", fileName, md380_CsvRetToString (ret));
		goto exitFunc;
	}

	for (i=0; i<container->DigitalRxGroupList_COUNT; i++) {
		ret = encodeCSVRecord_DigitalRxGroupList (i, separator, md380_FILEWriteBinaryFunc, f, container->DigitalRxGroupList+i, errorMessage);
		if (ret != CSVRET_OK) break;
	}


	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and reads all the records of 'DigitalRxGroupList'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFile_DigitalRxGroupList (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
{
	int ret;
	unsigned i, j, numberOfColumns;
	unsigned fieldsMap[FIELDS_DigitalRxGroupList];
	FILE* f = NULL;
	T_DigitalRxGroupList record;
	

	/* Clear the container */
	container->DigitalRxGroupList_COUNT = 0;

	
	/* Open the file for reading */
	f = fopen (fileName, "rb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for reading (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}
	
	/* Read the titles */
	ret = md380_ReadColumnsMapping (DESC_DigitalRxGroupList, FIELDS_DigitalRxGroupList, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
	if (ret != CSVRET_OK) goto exitFunc;
	
	/* Read the records */
	ret = CSVRET_EOF;
	for (i=0;;i++) {
		memset (&record, 0, sizeof(record));
	
		/* Read fields within records */
		for (j=0; ; j++) {
			if (j >= numberOfColumns) {
				(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
				sprintf ((*errorMessage), "In file '%s', line %d, too many columns\n", fileName, i+2);
				ret = MD380ERR_INVALID_CSV_FORMAT;
				goto exitFunc;
			}
			
			switch (fieldsMap[j]) {
				case 0: ret = md380_ReadFieldUnicode (DESC_DigitalRxGroupList+0, record.Name, 16, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 1: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+1, &(record.ContactMember[0]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 2: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+2, &(record.ContactMember[1]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 3: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+3, &(record.ContactMember[2]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 4: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+4, &(record.ContactMember[3]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 5: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+5, &(record.ContactMember[4]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 6: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+6, &(record.ContactMember[5]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 7: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+7, &(record.ContactMember[6]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 8: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+8, &(record.ContactMember[7]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 9: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+9, &(record.ContactMember[8]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 10: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+10, &(record.ContactMember[9]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 11: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+11, &(record.ContactMember[10]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 12: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+12, &(record.ContactMember[11]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 13: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+13, &(record.ContactMember[12]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 14: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+14, &(record.ContactMember[13]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 15: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+15, &(record.ContactMember[14]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 16: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+16, &(record.ContactMember[15]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 17: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+17, &(record.ContactMember[16]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 18: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+18, &(record.ContactMember[17]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 19: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+19, &(record.ContactMember[18]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 20: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+20, &(record.ContactMember[19]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 21: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+21, &(record.ContactMember[20]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 22: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+22, &(record.ContactMember[21]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 23: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+23, &(record.ContactMember[22]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 24: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+24, &(record.ContactMember[23]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 25: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+25, &(record.ContactMember[24]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 26: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+26, &(record.ContactMember[25]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 27: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+27, &(record.ContactMember[26]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 28: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+28, &(record.ContactMember[27]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 29: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+29, &(record.ContactMember[28]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 30: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+30, &(record.ContactMember[29]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 31: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+31, &(record.ContactMember[30]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 32: ret = md380_ReadFieldReferenceNumeric (DESC_DigitalRxGroupList+32, &(record.ContactMember[31]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				default: assert (0);
			}
			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
			if (ret != CSVRET_OK) goto exitFunc;
		}
		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
		if (j+1 < numberOfColumns) {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, missing columns\n", fileName, i+2);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* Abort if an unexpected result has been detected */
		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
		
		/* Add the record if in range */
		if (i < COUNT_DigitalRxGroupList) {
			memcpy (container->DigitalRxGroupList+i, &record, sizeof (record));
			container->DigitalRxGroupList_COUNT = i+1;
		}
		else {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+146);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, too many lines (MAX=%d)\n", fileName, i+2, COUNT_DigitalRxGroupList);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* If the last field included an EOF, we are done */
		if (ret == CSVRET_EOF) break;
	}
	ret = CSVRET_OK;
	
	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and saves all the records of 'GeneralSettings'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFile_GeneralSettings (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	FILE* f = NULL;
	
	assert (errorMessage != NULL);
	assert ((*errorMessage) == NULL);
	
	f = fopen (fileName, "wb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for writing (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}

	ret = encodeCSVHeader_GeneralSettings (separator, md380_FILEWriteBinaryFunc, f);
	if (ret != CSVRET_OK) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error writing CSV header when saving %s (%s)\n", fileName, md380_CsvRetToString (ret));
		goto exitFunc;
	}

	ret = encodeCSVRecord_GeneralSettings (0, separator, md380_FILEWriteBinaryFunc, f, &container->GeneralSettings, errorMessage);


	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and reads all the records of 'GeneralSettings'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFile_GeneralSettings (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
{
	int ret;
	unsigned i, j, numberOfColumns;
	unsigned fieldsMap[FIELDS_GeneralSettings];
	FILE* f = NULL;
	T_GeneralSettings record;
	

	
	/* Open the file for reading */
	f = fopen (fileName, "rb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for reading (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}
	
	/* Read the titles */
	ret = md380_ReadColumnsMapping (DESC_GeneralSettings, FIELDS_GeneralSettings, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
	if (ret != CSVRET_OK) goto exitFunc;
	
	/* Read the records */
	ret = CSVRET_EOF;
	for (i=0;;i++) {
		memset (&record, 0, sizeof(record));
	
		/* Read fields within records */
		for (j=0; ; j++) {
			if (j >= numberOfColumns) {
				(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
				sprintf ((*errorMessage), "In file '%s', line %d, too many columns\n", fileName, i+2);
				ret = MD380ERR_INVALID_CSV_FORMAT;
				goto exitFunc;
			}
			
			switch (fieldsMap[j]) {
				case 0: ret = md380_ReadFieldUnicode (DESC_GeneralSettings+0, record.InfoScreenLine1, 10, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 1: ret = md380_ReadFieldUnicode (DESC_GeneralSettings+1, record.InfoScreenLine2, 10, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 2: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+2, &(record.MonitorType), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 3: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+3, &(record.DisableAllLeds), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 4: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+4, &(record.TalkPermitTone), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 5: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+5, &(record.PasswordAndLockEnable), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 6: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+6, &(record.CHFreeIndicationTone), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 7: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+7, &(record.DisableAllTone), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 8: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+8, &(record.SaveModeReceive), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 9: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+9, &(record.SavePreamble), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 10: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+10, &(record.IntroScreen), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 11: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+11, &(record.RadioId), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 12: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+12, &(record.TxPreamble), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 13: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+13, &(record.GroupCallHangTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 14: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+14, &(record.PrivateCallHangTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 15: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+15, &(record.VoxSensitivity), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 16: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+16, &(record.RxLowBatteryInterval), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 17: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+17, &(record.CallAlertTone), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 18: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+18, &(record.LoneWorkerRespTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 19: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+19, &(record.LoneWorkerReminderTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 20: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+20, &(record.ScanDigitalHangTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 21: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+21, &(record.ScanAnalogHangTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 22: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+22, &(record.Unknown1), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 23: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+23, &(record.KeypadLockTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 24: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+24, &(record.Mode), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 25: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+25, &(record.PowerOnPassword), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 26: ret = md380_ReadFieldNumeric (DESC_GeneralSettings+26, &(record.RadioProgPassowrd), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 27: ret = md380_ReadFieldUnicode (DESC_GeneralSettings+27, record.PcProgPassword, 8, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 28: ret = md380_ReadFieldUnicode (DESC_GeneralSettings+28, record.RadioName, 16, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				default: assert (0);
			}
			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
			if (ret != CSVRET_OK) goto exitFunc;
		}
		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
		if (j+1 < numberOfColumns) {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, missing columns\n", fileName, i+2);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* Abort if an unexpected result has been detected */
		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
		
		/* Add the record if in range */
		if (i < COUNT_GeneralSettings) {
			memcpy (&container->GeneralSettings, &record, sizeof (record));
		}
		else {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, too many lines (MAX=%d)\n", fileName, i+2, COUNT_GeneralSettings);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* If the last field included an EOF, we are done */
		if (ret == CSVRET_EOF) break;
	}
	ret = CSVRET_OK;
	
	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and saves all the records of 'ScanList'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFile_ScanList (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	FILE* f = NULL;
	unsigned i;
	
	assert (errorMessage != NULL);
	assert ((*errorMessage) == NULL);
	
	f = fopen (fileName, "wb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+136);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for writing (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}

	ret = encodeCSVHeader_ScanList (separator, md380_FILEWriteBinaryFunc, f);
	if (ret != CSVRET_OK) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+136);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error writing CSV header when saving %s (%s)\n", fileName, md380_CsvRetToString (ret));
		goto exitFunc;
	}

	for (i=0; i<container->ScanList_COUNT; i++) {
		ret = encodeCSVRecord_ScanList (i, separator, md380_FILEWriteBinaryFunc, f, container->ScanList+i, errorMessage);
		if (ret != CSVRET_OK) break;
	}


	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and reads all the records of 'ScanList'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFile_ScanList (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
{
	int ret;
	unsigned i, j, numberOfColumns;
	unsigned fieldsMap[FIELDS_ScanList];
	FILE* f = NULL;
	T_ScanList record;
	

	/* Clear the container */
	container->ScanList_COUNT = 0;

	
	/* Open the file for reading */
	f = fopen (fileName, "rb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+136);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for reading (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}
	
	/* Read the titles */
	ret = md380_ReadColumnsMapping (DESC_ScanList, FIELDS_ScanList, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
	if (ret != CSVRET_OK) goto exitFunc;
	
	/* Read the records */
	ret = CSVRET_EOF;
	for (i=0;;i++) {
		memset (&record, 0, sizeof(record));
	
		/* Read fields within records */
		for (j=0; ; j++) {
			if (j >= numberOfColumns) {
				(*errorMessage) = (char*)binAlloc (strlen (fileName)+136);
				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
				sprintf ((*errorMessage), "In file '%s', line %d, too many columns\n", fileName, i+2);
				ret = MD380ERR_INVALID_CSV_FORMAT;
				goto exitFunc;
			}
			
			switch (fieldsMap[j]) {
				case 0: ret = md380_ReadFieldUnicode (DESC_ScanList+0, record.Name, 16, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 1: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+1, &(record.PriorityCh1), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 2: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+2, &(record.PriorityCh2), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 3: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+3, &(record.TXDesignatedCh), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 4: ret = md380_ReadFieldNumeric (DESC_ScanList+4, &(record.SignHoldTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 5: ret = md380_ReadFieldNumeric (DESC_ScanList+5, &(record.PrioSamplTime), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 6: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+6, &(record.ChannelMember[0]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 7: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+7, &(record.ChannelMember[1]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 8: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+8, &(record.ChannelMember[2]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 9: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+9, &(record.ChannelMember[3]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 10: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+10, &(record.ChannelMember[4]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 11: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+11, &(record.ChannelMember[5]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 12: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+12, &(record.ChannelMember[6]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 13: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+13, &(record.ChannelMember[7]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 14: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+14, &(record.ChannelMember[8]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 15: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+15, &(record.ChannelMember[9]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 16: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+16, &(record.ChannelMember[10]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 17: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+17, &(record.ChannelMember[11]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 18: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+18, &(record.ChannelMember[12]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 19: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+19, &(record.ChannelMember[13]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 20: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+20, &(record.ChannelMember[14]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 21: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+21, &(record.ChannelMember[15]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 22: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+22, &(record.ChannelMember[16]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 23: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+23, &(record.ChannelMember[17]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 24: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+24, &(record.ChannelMember[18]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 25: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+25, &(record.ChannelMember[19]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 26: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+26, &(record.ChannelMember[20]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 27: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+27, &(record.ChannelMember[21]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 28: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+28, &(record.ChannelMember[22]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 29: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+29, &(record.ChannelMember[23]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 30: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+30, &(record.ChannelMember[24]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 31: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+31, &(record.ChannelMember[25]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 32: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+32, &(record.ChannelMember[26]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 33: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+33, &(record.ChannelMember[27]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 34: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+34, &(record.ChannelMember[28]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 35: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+35, &(record.ChannelMember[29]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 36: ret = md380_ReadFieldReferenceUnicode (DESC_ScanList+36, &(record.ChannelMember[30]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				default: assert (0);
			}
			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
			if (ret != CSVRET_OK) goto exitFunc;
		}
		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
		if (j+1 < numberOfColumns) {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+136);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, missing columns\n", fileName, i+2);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* Abort if an unexpected result has been detected */
		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
		
		/* Add the record if in range */
		if (i < COUNT_ScanList) {
			memcpy (container->ScanList+i, &record, sizeof (record));
			container->ScanList_COUNT = i+1;
		}
		else {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+136);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, too many lines (MAX=%d)\n", fileName, i+2, COUNT_ScanList);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* If the last field included an EOF, we are done */
		if (ret == CSVRET_EOF) break;
	}
	ret = CSVRET_OK;
	
	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and saves all the records of 'TextMessage'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFile_TextMessage (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	FILE* f = NULL;
	unsigned i;
	
	assert (errorMessage != NULL);
	assert ((*errorMessage) == NULL);
	
	f = fopen (fileName, "wb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+139);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for writing (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}

	ret = encodeCSVHeader_TextMessage (separator, md380_FILEWriteBinaryFunc, f);
	if (ret != CSVRET_OK) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+139);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error writing CSV header when saving %s (%s)\n", fileName, md380_CsvRetToString (ret));
		goto exitFunc;
	}

	for (i=0; i<container->TextMessage_COUNT; i++) {
		ret = encodeCSVRecord_TextMessage (i, separator, md380_FILEWriteBinaryFunc, f, container->TextMessage+i, errorMessage);
		if (ret != CSVRET_OK) break;
	}


	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and reads all the records of 'TextMessage'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFile_TextMessage (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
{
	int ret;
	unsigned i, j, numberOfColumns;
	unsigned fieldsMap[FIELDS_TextMessage];
	FILE* f = NULL;
	T_TextMessage record;
	

	/* Clear the container */
	container->TextMessage_COUNT = 0;

	
	/* Open the file for reading */
	f = fopen (fileName, "rb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+139);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for reading (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}
	
	/* Read the titles */
	ret = md380_ReadColumnsMapping (DESC_TextMessage, FIELDS_TextMessage, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
	if (ret != CSVRET_OK) goto exitFunc;
	
	/* Read the records */
	ret = CSVRET_EOF;
	for (i=0;;i++) {
		memset (&record, 0, sizeof(record));
	
		/* Read fields within records */
		for (j=0; ; j++) {
			if (j >= numberOfColumns) {
				(*errorMessage) = (char*)binAlloc (strlen (fileName)+139);
				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
				sprintf ((*errorMessage), "In file '%s', line %d, too many columns\n", fileName, i+2);
				ret = MD380ERR_INVALID_CSV_FORMAT;
				goto exitFunc;
			}
			
			switch (fieldsMap[j]) {
				case 0: ret = md380_ReadFieldUnicode (DESC_TextMessage+0, record.Text, 144, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				default: assert (0);
			}
			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
			if (ret != CSVRET_OK) goto exitFunc;
		}
		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
		if (j+1 < numberOfColumns) {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+139);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, missing columns\n", fileName, i+2);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* Abort if an unexpected result has been detected */
		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
		
		/* Add the record if in range */
		if (i < COUNT_TextMessage) {
			memcpy (container->TextMessage+i, &record, sizeof (record));
			container->TextMessage_COUNT = i+1;
		}
		else {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+139);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, too many lines (MAX=%d)\n", fileName, i+2, COUNT_TextMessage);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* If the last field included an EOF, we are done */
		if (ret == CSVRET_EOF) break;
	}
	ret = CSVRET_OK;
	
	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and saves all the records of 'ZoneInformation'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFile_ZoneInformation (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	FILE* f = NULL;
	unsigned i;
	
	assert (errorMessage != NULL);
	assert ((*errorMessage) == NULL);
	
	f = fopen (fileName, "wb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for writing (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}

	ret = encodeCSVHeader_ZoneInformation (separator, md380_FILEWriteBinaryFunc, f);
	if (ret != CSVRET_OK) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error writing CSV header when saving %s (%s)\n", fileName, md380_CsvRetToString (ret));
		goto exitFunc;
	}

	for (i=0; i<container->ZoneInformation_COUNT; i++) {
		ret = encodeCSVRecord_ZoneInformation (i, separator, md380_FILEWriteBinaryFunc, f, container->ZoneInformation+i, errorMessage);
		if (ret != CSVRET_OK) break;
	}


	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and reads all the records of 'ZoneInformation'. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFile_ZoneInformation (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
{
	int ret;
	unsigned i, j, numberOfColumns;
	unsigned fieldsMap[FIELDS_ZoneInformation];
	FILE* f = NULL;
	T_ZoneInformation record;
	

	/* Clear the container */
	container->ZoneInformation_COUNT = 0;

	
	/* Open the file for reading */
	f = fopen (fileName, "rb");
	if (f == NULL) {
		(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
		sprintf ((*errorMessage), "Error opening '%s' for reading (%s)\n", fileName, strerror (errno));
		ret = MD380ERR_FILE_ERROR;
		goto exitFunc;
	}
	
	/* Read the titles */
	ret = md380_ReadColumnsMapping (DESC_ZoneInformation, FIELDS_ZoneInformation, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
	if (ret != CSVRET_OK) goto exitFunc;
	
	/* Read the records */
	ret = CSVRET_EOF;
	for (i=0;;i++) {
		memset (&record, 0, sizeof(record));
	
		/* Read fields within records */
		for (j=0; ; j++) {
			if (j >= numberOfColumns) {
				(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
				sprintf ((*errorMessage), "In file '%s', line %d, too many columns\n", fileName, i+2);
				ret = MD380ERR_INVALID_CSV_FORMAT;
				goto exitFunc;
			}
			
			switch (fieldsMap[j]) {
				case 0: ret = md380_ReadFieldUnicode (DESC_ZoneInformation+0, record.Name, 16, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage); break;
				case 1: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+1, &(record.ChannelMember[0]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 2: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+2, &(record.ChannelMember[1]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 3: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+3, &(record.ChannelMember[2]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 4: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+4, &(record.ChannelMember[3]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 5: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+5, &(record.ChannelMember[4]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 6: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+6, &(record.ChannelMember[5]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 7: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+7, &(record.ChannelMember[6]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 8: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+8, &(record.ChannelMember[7]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 9: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+9, &(record.ChannelMember[8]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 10: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+10, &(record.ChannelMember[9]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 11: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+11, &(record.ChannelMember[10]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 12: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+12, &(record.ChannelMember[11]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 13: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+13, &(record.ChannelMember[12]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 14: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+14, &(record.ChannelMember[13]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 15: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+15, &(record.ChannelMember[14]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				case 16: ret = md380_ReadFieldReferenceUnicode (DESC_ZoneInformation+16, &(record.ChannelMember[15]), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);; break;
				default: assert (0);
			}
			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
			if (ret != CSVRET_OK) goto exitFunc;
		}
		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
		if (j+1 < numberOfColumns) {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, missing columns\n", fileName, i+2);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* Abort if an unexpected result has been detected */
		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
		
		/* Add the record if in range */
		if (i < COUNT_ZoneInformation) {
			memcpy (container->ZoneInformation+i, &record, sizeof (record));
			container->ZoneInformation_COUNT = i+1;
		}
		else {
			(*errorMessage) = (char*)binAlloc (strlen (fileName)+143);
			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
			sprintf ((*errorMessage), "In file '%s', line %d, too many lines (MAX=%d)\n", fileName, i+2, COUNT_ZoneInformation);
			ret = MD380ERR_INVALID_CSV_FORMAT;
			goto exitFunc;
		}
		
		/* If the last field included an EOF, we are done */
		if (ret == CSVRET_EOF) break;
	}
	ret = CSVRET_OK;
	
	exitFunc:
	if (f) fclose (f);
	return ret;
}

/* Function that opens a file and saves all the records in various CSV files. */
/* The files are saved according to the CSVFileNames structure. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int saveCSVFileAll (const CSVFileNames* csvFileNames, const TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	
	
	/* SAVE RECORD ChannelInformation */
	if (csvFileNames->Path_ChannelInformation) {
		ret = saveCSVFile_ChannelInformation (csvFileNames->Path_ChannelInformation, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* SAVE RECORD DigitalContact */
	if (csvFileNames->Path_DigitalContact) {
		ret = saveCSVFile_DigitalContact (csvFileNames->Path_DigitalContact, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* SAVE RECORD DigitalRxGroupList */
	if (csvFileNames->Path_DigitalRxGroupList) {
		ret = saveCSVFile_DigitalRxGroupList (csvFileNames->Path_DigitalRxGroupList, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* SAVE RECORD GeneralSettings */
	if (csvFileNames->Path_GeneralSettings) {
		ret = saveCSVFile_GeneralSettings (csvFileNames->Path_GeneralSettings, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* SAVE RECORD ScanList */
	if (csvFileNames->Path_ScanList) {
		ret = saveCSVFile_ScanList (csvFileNames->Path_ScanList, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* SAVE RECORD TextMessage */
	if (csvFileNames->Path_TextMessage) {
		ret = saveCSVFile_TextMessage (csvFileNames->Path_TextMessage, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* SAVE RECORD ZoneInformation */
	if (csvFileNames->Path_ZoneInformation) {
		ret = saveCSVFile_ZoneInformation (csvFileNames->Path_ZoneInformation, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}

	
	exitFunc:
	return ret;
}
/* Function that loads all the records from various CSV files. */
/* The files are loaded according to the CSVFileNames structure. */
/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
/* describing the error, is allocated with binAlloc in case of error */
/* and it is to be freed with binFree. */
int loadCSVFileAll (const CSVFileNames* csvFileNames, TRDTFile* container, char separator, char** errorMessage)
{
	int ret = CSVRET_OK;
	
	
	/* LOAD RECORD ChannelInformation */
	if (csvFileNames->Path_ChannelInformation) {
		ret = loadCSVFile_ChannelInformation (csvFileNames->Path_ChannelInformation, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* LOAD RECORD DigitalContact */
	if (csvFileNames->Path_DigitalContact) {
		ret = loadCSVFile_DigitalContact (csvFileNames->Path_DigitalContact, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* LOAD RECORD DigitalRxGroupList */
	if (csvFileNames->Path_DigitalRxGroupList) {
		ret = loadCSVFile_DigitalRxGroupList (csvFileNames->Path_DigitalRxGroupList, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* LOAD RECORD GeneralSettings */
	if (csvFileNames->Path_GeneralSettings) {
		ret = loadCSVFile_GeneralSettings (csvFileNames->Path_GeneralSettings, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* LOAD RECORD ScanList */
	if (csvFileNames->Path_ScanList) {
		ret = loadCSVFile_ScanList (csvFileNames->Path_ScanList, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* LOAD RECORD TextMessage */
	if (csvFileNames->Path_TextMessage) {
		ret = loadCSVFile_TextMessage (csvFileNames->Path_TextMessage, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}
	
	/* LOAD RECORD ZoneInformation */
	if (csvFileNames->Path_ZoneInformation) {
		ret = loadCSVFile_ZoneInformation (csvFileNames->Path_ZoneInformation, container, separator, errorMessage);
		if (ret != CSVRET_OK) goto exitFunc;
		assert ((*errorMessage) == NULL);
	}

	
	exitFunc:
	return ret;
}
