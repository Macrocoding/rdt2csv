lifeset CORE;

phase generateFile = 30;

in phase generateFile {
	do {
		// Prepare the file names
		var FilePath cFileName;
		var FilePath hFileName;
		cFileName.parse (outputName.text+"_file");
		hFileName.parse (outputName.text+"_file");
		cFileName.replaceExtension ("c");
		hFileName.replaceExtension ("h");

		// Open the files
		var FileOutStream cFile (cFileName);
		var FileOutStream hFile (hFileName);
		system().msg << "Generating " << cFileName << endl;
		system().msg << "Generating " << hFileName << endl;

		// Write the headers
		cFile << %F
%f			%F%1/* Generated by Macrocoder - do not edit */
%f%0			%F%1#define _CRT_SECURE_NO_WARNINGS
%f%0			%F%1#include "%0«hFileName.%fgetTopNamePart ()%F»%1"
%f%0			%F%1#include <stdio.h>
%f%0			%F%1#include <assert.h>
%f%0			%F%1#include <errno.h>
%f%0		;
		
		var String ifndefText = %FhFileName.%fgetTopNamePart ().convertToIdentifier ();
		hFile << %F
%f			%F%1/* Generated by Macrocoder - do not edit */
%f%0			%F%1#ifndef %0«ifndefText»%1
%f%0			%F%1#define %0«ifndefText»%1
%f%0			%F%1
%f%0			%F%1#include "%0«getInclude("")»%1"
%f%0			%F%1#include "md380_tools.h"
%f%0			%F%1#include "%0«getInclude("_cli")»%1"
%f%0			%F%1#include "%0«getInclude("_csv")»%1"
%f%0		;
	
			// Write the record structures
		var Int i;
		for (i=0; i<recordsMap.count (); i++) {
			recordsMap.getAt (i).genFileFuncsH(hFile);
			recordsMap.getAt (i).genFileFuncsCSave(cFile);
			recordsMap.getAt (i).genFileFuncsCLoad(cFile);
		}
		
		genFileSaveAll(hFile,cFile);
		genFileLoadAll(hFile,cFile);
	
		// Write the footers
		hFile << endl <<
			%F%1#endif
%f%0		%F;%f
	}
	shared Void genFileSaveAll (out TextStream hFile, out TextStream cFile) const;
	shared Void genFileLoadAll (out TextStream hFile, out TextStream cFile) const;
}

extend class Record {
	in phase generateFile {
		shared Void genFileFuncsH (out TextStream hFile) const;
		shared Void genFileFuncsCSave (out TextStream cFile) const;
		shared Void genFileFuncsCLoad (out TextStream cFile) const;
	}
}

extend class FieldType {
	in phase generateFile {shared Void genFileFuncsCLoadField (out TextStream cFile, Int fieldNo, Int repNo) const {}}
}

extend class FieldTypeNumeric {
	in phase generateFile {shared Void genFileFuncsCLoadField (out TextStream cFile, Int fieldNo, Int repNo) const;}
}

extend class FieldTypeUnicode {
	in phase generateFile {shared Void genFileFuncsCLoadField (out TextStream cFile, Int fieldNo, Int repNo) const;}
}

extend class FieldTypeAscii {
	in phase generateFile {shared Void genFileFuncsCLoadField (out TextStream cFile, Int fieldNo, Int repNo) const;}
}

/*======================================================================
	HEADERS
======================================================================*/
impl Record::genFileFuncsH {
	hFile << endl <<
		%F%1/* Function that opens a file and saves all the records of '%0«recordId»%1'. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1extern int saveCSVFile_%0«recordId»%1 (const char* fileName, const TRDTFile* container, char separator, char** errorMessage);
%f%0		%F%1
%f%0		%F%1/* Function that opens a file and reads all the records of '%0«recordId»%1'. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1extern int loadCSVFile_%0«recordId»%1 (const char* fileName, TRDTFile* container, char separator, char** errorMessage);
%f%0	
	;
}

/*======================================================================
	SAVE
======================================================================*/
impl Record::genFileFuncsCSave {
	var Int fixSize = 128 + recordId.text.length();
	cFile << endl <<
		%F%1/* Function that opens a file and saves all the records of '%0«recordId»%1'. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1int saveCSVFile_%0«recordId»%1 (const char* fileName, const TRDTFile* container, char separator, char** errorMessage)
%f%0		%F%1{
%f%0		%F%1	int ret = CSVRET_OK;
%f%0		%F%1	FILE* f = NULL;
%f%0	;
	if (count.value > 1) {
		cFile <<
			%F%1	unsigned i;
%f%0		;
	}
	cFile <<
		%F%1	
%f%0		%F%1	assert (errorMessage != NULL);
%f%0		%F%1	assert ((*errorMessage) == NULL);
%f%0		%F%1	
%f%0		%F%1	f = fopen (fileName, "wb");
%f%0		%F%1	if (f == NULL) {
%f%0		%F%1		(*errorMessage) = (char*)binAlloc (strlen (fileName)+%0«fixSize»%1);
%f%0		%F%1		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
%f%0		%F%1		sprintf ((*errorMessage), "Error opening '%%s' for writing (%%s)\n", fileName, strerror (errno));
%f%0		%F%1		ret = MD380ERR_FILE_ERROR;
%f%0		%F%1		goto exitFunc;
%f%0		%F%1	}
%f%0		%F%1
%f%0		%F%1	ret = encodeCSVHeader_%0«recordId»%1 (separator, md380_FILEWriteBinaryFunc, f);
%f%0		%F%1	if (ret != CSVRET_OK) {
%f%0		%F%1		(*errorMessage) = (char*)binAlloc (strlen (fileName)+%0«fixSize»%1);
%f%0		%F%1		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
%f%0		%F%1		sprintf ((*errorMessage), "Error writing CSV header when saving %%s (%%s)\n", fileName, md380_CsvRetToString (ret));
%f%0		%F%1		goto exitFunc;
%f%0		%F%1	}
%f%0	;
	if (count.value > 1) {
		cFile << endl <<
			%F%1	for (i=0; i<container->%0«recordId»%1_COUNT; i++) {
%f%0			%F%1		ret = encodeCSVRecord_%0«recordId»%1 (i, separator, md380_FILEWriteBinaryFunc, f, container->%0«recordId»%1+i, errorMessage);
%f%0			%F%1		if (ret != CSVRET_OK) break;
%f%0			%F%1	}
%f%0		;
	}
	else {
		cFile << endl <<
			%F%1	ret = encodeCSVRecord_%0«recordId»%1 (0, separator, md380_FILEWriteBinaryFunc, f, &container->%0«recordId»%1, errorMessage);
%f%0		;
	}
	cFile << endl <<
		%F%1
%f%0		%F%1	exitFunc:
%f%0		%F%1	if (f) fclose (f);
%f%0		%F%1	return ret;
%f%0		%F%1}
%f%0	;
}

/*======================================================================
	LOAD
======================================================================*/
impl Record::genFileFuncsCLoad {
	var Int fixSize = 128 + recordId.text.length();
	cFile << endl <<
		%F%1/* Function that opens a file and reads all the records of '%0«recordId»%1'. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1int loadCSVFile_%0«recordId»%1 (const char* fileName, TRDTFile* container, char separator, char** errorMessage)
%f%0		%F%1{
%f%0		%F%1	int ret;
%f%0		%F%1	unsigned i, j, numberOfColumns;
%f%0		%F%1	unsigned fieldsMap[FIELDS_%0«recordId»%1];
%f%0		%F%1	FILE* f = NULL;
%f%0		%F%1	T_%0«recordId»%1 record;
%f%0		%F%1	
%f%0	;
	if (count.value > 1) {
		cFile << endl <<
			%F%1	/* Clear the container */
%f%0			%F%1	container->%0«recordId»%1_COUNT = 0;
%f%0		;
	}
	cFile << endl <<
		%F%1	
%f%0		%F%1	/* Open the file for reading */
%f%0		%F%1	f = fopen (fileName, "rb");
%f%0		%F%1	if (f == NULL) {
%f%0		%F%1		(*errorMessage) = (char*)binAlloc (strlen (fileName)+%0«fixSize»%1);
%f%0		%F%1		if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
%f%0		%F%1		sprintf ((*errorMessage), "Error opening '%%s' for reading (%%s)\n", fileName, strerror (errno));
%f%0		%F%1		ret = MD380ERR_FILE_ERROR;
%f%0		%F%1		goto exitFunc;
%f%0		%F%1	}
%f%0		%F%1	
%f%0		%F%1	/* Read the titles */
%f%0		%F%1	ret = md380_ReadColumnsMapping (DESC_%0«recordId»%1, FIELDS_%0«recordId»%1, fieldsMap, &numberOfColumns, separator, md380_FILEReadCharFunc, f, errorMessage);
%f%0		%F%1	if (ret != CSVRET_OK) goto exitFunc;
%f%0		%F%1	
%f%0		%F%1	/* Read the records */
%f%0		%F%1	ret = CSVRET_EOF;
%f%0		%F%1	for (i=0;;i++) {
%f%0		%F%1		memset (&record, 0, sizeof(record));
%f%0		%F%1	
%f%0		%F%1		/* Read fields within records */
%f%0		%F%1		for (j=0; ; j++) {
%f%0		%F%1			if (j >= numberOfColumns) {
%f%0		%F%1				(*errorMessage) = (char*)binAlloc (strlen (fileName)+%0«fixSize»%1);
%f%0		%F%1				if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
%f%0		%F%1				sprintf ((*errorMessage), "In file '%%s', line %%d, too many columns\n", fileName, i+2);
%f%0		%F%1				ret = MD380ERR_INVALID_CSV_FORMAT;
%f%0		%F%1				goto exitFunc;
%f%0		%F%1			}
%f%0		%F%1			
%f%0		%F%1			switch (fieldsMap[j]) {
%f%0	;
	cFile.incIndent ();
	cFile.incIndent ();
	cFile.incIndent ();
	cFile.incIndent ();
	
	var Int i;
	var Int pos=0;
	for (i=0; i<fields.count (); i++) {
		var Int reps = fields.get(i).repetitions.value;
		if (reps <= 1) {
			cFile << %F%1case %f%0«pos»%1: %0;
			fields.get(i).fieldType.genFileFuncsCLoadField(cFile, pos, -1);
			cFile << %F%1 break;%0 << endl;%f
			pos++;
		}
		else {
			var Int j;
			for (j=0; j<reps; j++) {
				cFile << %F%1case %f%0«pos»%1: %0;
				fields.get(i).fieldType.genFileFuncsCLoadField(cFile, pos, j);
				cFile << %F%1; break;%0 << endl;%f
				pos++;
			}
		}
	}

	cFile.decIndent ();
	cFile.decIndent ();
	cFile.decIndent ();
	cFile.decIndent ();

	cFile <<
		%F%1				default: assert (0);
%f%0		%F%1			}
%f%0		%F%1			if (ret == CSVRET_EOL || ret == CSVRET_EOF || ret == MD380ERR_EMPTY_EOF) break;
%f%0		%F%1			if (ret != CSVRET_OK) goto exitFunc;
%f%0		%F%1		}
%f%0		%F%1		if (j == 0 && ret == MD380ERR_EMPTY_EOF) break;
%f%0		%F%1		if (j+1 < numberOfColumns) {
%f%0		%F%1			(*errorMessage) = (char*)binAlloc (strlen (fileName)+%0«fixSize»%1);
%f%0		%F%1			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
%f%0		%F%1			sprintf ((*errorMessage), "In file '%%s', line %%d, missing columns\n", fileName, i+2);
%f%0		%F%1			ret = MD380ERR_INVALID_CSV_FORMAT;
%f%0		%F%1			goto exitFunc;
%f%0		%F%1		}
%f%0		%F%1		
%f%0		%F%1		/* Abort if an unexpected result has been detected */
%f%0		%F%1		if (ret != CSVRET_EOL && ret != CSVRET_EOF) break;
%f%0		%F%1		
%f%0		%F%1		/* Add the record if in range */
%f%0		%F%1		if (i < COUNT_%0«recordId»%1) {
%f%0	;
	if (count.value > 1) {
		cFile <<
			%F%1			memcpy (container->%0«recordId»%1+i, &record, sizeof (record));
%f%0			%F%1			container->%0«recordId»%1_COUNT = i+1;
%f%0		;
	}
	else {
		cFile <<
			%F%1			memcpy (&container->%0«recordId»%1, &record, sizeof (record));
%f%0		;
	}
	cFile <<
		%F%1		}
%f%0		%F%1		else {
%f%0		%F%1			(*errorMessage) = (char*)binAlloc (strlen (fileName)+%0«fixSize»%1);
%f%0		%F%1			if ((*errorMessage) == NULL) {ret = CSVRET_OUT_OF_MEMORY; goto exitFunc;}
%f%0		%F%1			sprintf ((*errorMessage), "In file '%%s', line %%d, too many lines (MAX=%%d)\n", fileName, i+2, COUNT_%0«recordId»%1);
%f%0		%F%1			ret = MD380ERR_INVALID_CSV_FORMAT;
%f%0		%F%1			goto exitFunc;
%f%0		%F%1		}
%f%0		%F%1		
%f%0		%F%1		/* If the last field included an EOF, we are done */
%f%0		%F%1		if (ret == CSVRET_EOF) break;
%f%0		%F%1	}
%f%0		%F%1	ret = CSVRET_OK;
%f%0		%F%1	
%f%0		%F%1	exitFunc:
%f%0		%F%1	if (f) fclose (f);
%f%0		%F%1	return ret;
%f%0		%F%1}
%f%0	;
}

/*======================================================================
	SAVE ALL
======================================================================*/
impl genFileSaveAll {
	var Int i;

	hFile << endl <<
		%F%1/* Function that opens a file and saves all the records in various CSV files. */
%f%0		%F%1/* The files are saved according to the CSVFileNames structure. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1extern int saveCSVFileAll (const CSVFileNames* csvFileNames, const TRDTFile* container, char separator, char** errorMessage);
%f%0	;

	cFile << endl <<
		%F%1/* Function that opens a file and saves all the records in various CSV files. */
%f%0		%F%1/* The files are saved according to the CSVFileNames structure. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1int saveCSVFileAll (const CSVFileNames* csvFileNames, const TRDTFile* container, char separator, char** errorMessage)
%f%0		%F%1{
%f%0		%F%1	int ret = CSVRET_OK;
%f%0		%F%1	
%f%0	;
	cFile.incIndent ();
	for (i=0; i<recordsMap.count (); i++) {
		var String recordId = recordsMap.getAt(i).recordId.text;
		cFile <<
			%F%1
%f%0			%F%1/* SAVE RECORD %0«recordId»%1 */
%f%0			%F%1if (csvFileNames->Path_%0«recordId»%1) {
%f%0			%F%1	ret = saveCSVFile_%0«recordId»%1 (csvFileNames->Path_%0«recordId»%1, container, separator, errorMessage);
%f%0			%F%1	if (ret != CSVRET_OK) goto exitFunc;
%f%0			%F%1	assert ((*errorMessage) == NULL);
%f%0			%F%1}
%f%0		;
	}
	
	
	cFile.decIndent ();
	cFile << endl <<
		%F%1	
%f%0		%F%1	exitFunc:
%f%0		%F%1	return ret;
%f%0		%F%1}%f%0
	;
}
%F
%f/*======================================================================
	LOAD ALL
======================================================================*/
impl genFileLoadAll {
	var Int i;
	
	hFile << endl <<
		%F%1/* Function that loads all the records from various CSV files. */
%f%0		%F%1/* The files are loaded according to the CSVFileNames structure. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1extern int loadCSVFileAll (const CSVFileNames* csvFileNames, TRDTFile* container, char separator, char** errorMessage);
%f%0	;

	cFile << endl <<
		%F%1/* Function that loads all the records from various CSV files. */
%f%0		%F%1/* The files are loaded according to the CSVFileNames structure. */
%f%0		%F%1/* Returns one of the CSVRET_XXX values. The 'errorMessage' string, */
%f%0		%F%1/* describing the error, is allocated with binAlloc in case of error */
%f%0		%F%1/* and it is to be freed with binFree. */
%f%0		%F%1int loadCSVFileAll (const CSVFileNames* csvFileNames, TRDTFile* container, char separator, char** errorMessage)
%f%0		%F%1{
%f%0		%F%1	int ret = CSVRET_OK;
%f%0		%F%1	
%f%0	;
	cFile.incIndent ();
	for (i=0; i<recordsMap.count (); i++) {
		var String recordId = recordsMap.getAt(i).recordId.text;
		cFile <<
			%F%1
%f%0			%F%1/* LOAD RECORD %0«recordId»%1 */
%f%0			%F%1if (csvFileNames->Path_%0«recordId»%1) {
%f%0			%F%1	ret = loadCSVFile_%0«recordId»%1 (csvFileNames->Path_%0«recordId»%1, container, separator, errorMessage);
%f%0			%F%1	if (ret != CSVRET_OK) goto exitFunc;
%f%0			%F%1	assert ((*errorMessage) == NULL);
%f%0			%F%1}
%f%0		;
	}
	
	
	cFile.decIndent ();
	cFile << endl <<
		%F%1	
%f%0		%F%1	exitFunc:
%f%0		%F%1	return ret;
%f%0		%F%1}%f%0
	;
}
%F
impl FieldTypeNumeric::genFileFuncsCLoadField {
	var String arr;
	var String cmd;
	if (repNo >= 0) {arr = "["+str(repNo)+"]";}
	if (%fboundTableLink%F.valid()) {cmd=%fboundTableLink%F.keyField.fieldType.getReadFieldReference();} else {cmd="md380_ReadFieldNumeric";}
	cFile << %1ret = %0«cmd»%1 (DESC_%0«upscan(Record).recordId»%1+%0«fieldNo»%1, &(record.%0«upscan(Field).fieldId<<arr»%1), fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);%0;
}

impl FieldTypeUnicode::genFileFuncsCLoadField {
	cFile << %1ret = md380_ReadFieldUnicode (DESC_%0«upscan(Record).recordId»%1+%0«fieldNo»%1, record.%0«upscan(Field).fieldId»%1, %0«upscan(Field).%flengthBits%F.%fvalue%F/16»%1, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);%0;
}

impl FieldTypeAscii::genFileFuncsCLoadField {
	cFile << %1ret = md380_ReadFieldUnicode (DESC_%0«upscan(Record).recordId»%1+%0«fieldNo»%1, record.%0«upscan(Field).fieldId»%1, %0«upscan(Field).%flengthBits%F.%fvalue%F/8»%1, fileName, i+2, separator, md380_FILEReadCharFunc, f, errorMessage);%0;
}
