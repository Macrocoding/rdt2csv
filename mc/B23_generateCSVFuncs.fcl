lifeset CORE;

phase generateCSVFuncs = 23;

in phase generateCSVFuncs {
	do {
		// Prepare the file names
		var FilePath cFileName;
		var FilePath hFileName;
		cFileName.parse (outputName.text+"_csv");
		hFileName.parse (outputName.text+"_csv");
		cFileName.replaceExtension ("c");
		hFileName.replaceExtension ("h");

		// Open the files
		var FileOutStream cFile (cFileName);
		var FileOutStream hFile (hFileName);
		
		system().msg << "Generating " << cFileName << endl;
		system().msg << "Generating " << hFileName << endl;
	
		// Write the headers
		cFile << %F
%f			%F%1/* Generated by Macrocoder - do not edit */
%f%0			%F%1#define _CRT_SECURE_NO_WARNINGS
%f%0			%F%1#include "%0«hFileName.%fgetTopNamePart ()%F»%1"
%f%0			%F%1#include <stdio.h>
%f%0			%F%1#include <assert.h>
%f%0			%F%1#include "md380_tools.h"
%f%0		;
		
		var String ifndefText = %FhFileName.%fgetTopNamePart ().convertToIdentifier ();
		hFile << %F
%f			%F%1/* Generated by Macrocoder - do not edit */
%f%0			%F%1#ifndef %0«ifndefText»%1
%f%0			%F%1#define %0«ifndefText»%1
%f%0			%F%1
%f%0			%F%1#include "%0«getInclude("")»%1"
%f%0			%F%1#include "md380_tools.h"
%f%0			%F%1#include "%0«getInclude("_cli")»%1"
%f%0		;
	
			// Write the record structures
		var Int i;
		for (i=0; i<recordsMap.count (); i++) {
			recordsMap.getAt (i).genCSVFuncH(hFile);
			recordsMap.getAt (i).genCSVFuncC(cFile);
		}
		
	
		// Write the footers
		hFile << endl <<
			%F%1#endif
%f%0		%F;%f
	}
}

extend class Record {
	in phase generateCSVFuncs {
		shared Void genCSVFuncH (out TextStream hFile) const {
			%F
%f			%FhFile << endl << 
%f				%F%1/* Function that encodes a structure into a binary record. Parameters */
%f%0				%F%1/* and return values are the same of 'csvWriteSeparator' */
%f%0				%F%1extern int encodeCSVHeader_%0«recordId»%1 (char separator, WriteBinaryFunc writeBinaryFunc, void* writeBinaryFuncParameter);
%f%0				%F%1
%f%0				%F%1/* Function that encodes a binary empty record. Parameters */
%f%0				%F%1/* and return values are the same of 'csvWriteSeparator */
%f%0				%F%1extern int encodeCSVRecord_%0«recordId»%1 (unsigned lineNo, char separator, WriteBinaryFunc writeBinaryFunc, void* writeBinaryFuncParameter, const T_%0«recordId»%1* record, char** errorMessage);
%f%0			%F;%f
		}

		shared Void genCSVFuncC (out TextStream cFile) const {
			genCSVHeaderFuncC (cFile);
			genCSVRecordFuncC (cFile);
		}

		shared Void genCSVHeaderFuncC (out TextStream cFile) const;
		shared Void genCSVRecordFuncC (out TextStream cFile) const;
	}
}

extend class Field {
	in phase generateCSVFuncs {
		shared Void genCSVRecordFuncC (out TextStream cFile, Int fieldNum) const {fieldType.genCSVRecordFuncC (cFile, fieldNum);}
	}
}

extend class FieldType {
	in phase generateCSVFuncs {
		shared Void genCSVRecordFuncC (out TextStream cFile, Int fieldNum) const {cFile << "#error missing implementation of " << objinfo(this) << "::genCSVRecordFuncC" << endl;}
	}
}

extend class FieldTypeNumeric {
	in phase generateCSVFuncs {
		shared Void genCSVRecordFuncC (out TextStream cFile, Int fieldNum) const;
	}
}

extend class FieldTypeUnicode {
	in phase generateCSVFuncs {
		shared Void genCSVRecordFuncC (out TextStream cFile, Int fieldNum) const;
	}
}

/*-------------------------------------------------------------------------
	GENERATE THE ENCODE CSV HEADER FUNCTION
-------------------------------------------------------------------------*/
impl Record::genCSVHeaderFuncC {
	cFile << endl <<
		%F%1/* Function that encodes a structure into a binary record. Parameters */
%f%0		%F%1/* and return values are the same of 'csvWriteSeparator' */
%f%0		%F%1int encodeCSVHeader_%0«recordId»%1 (char separator, WriteBinaryFunc writeBinaryFunc, void* writeBinaryFuncParameter)
%f%0		%F%1{
%f%0		%F%1	int i;
%f%0		%F%1	int ret;
%f%0		%F%1	char* buf = NULL;
%f%0		%F%1	for (i=0; i<FIELDS_%0«recordId»%1; i++) {
%f%0		%F%1		if (i > 0) {
%f%0		%F%1			ret = csvWriteSeparator (separator, writeBinaryFunc, writeBinaryFuncParameter);
%f%0		%F%1			if (ret != CSVRET_OK) goto exitFunc;
%f%0		%F%1		}
%f%0		%F%1		ret = csvWriteToken (DESC_%0«recordId»%1[i].fieldName, -1, writeBinaryFunc, writeBinaryFuncParameter);
%f%0		%F%1		if (ret != CSVRET_OK) goto exitFunc;
%f%0		%F%1	}
%f%0		%F%1	ret = csvWriteEndOfLine (writeBinaryFunc, writeBinaryFuncParameter);
%f%0		%F%1	
%f%0		%F%1	exitFunc:
%f%0		%F%1	if (buf) binFree (buf);
%f%0		%F%1	return ret;
%f%0		%F%1}
%f%0	%F;%f	

}


/*-------------------------------------------------------------------------
	GENERATE THE ENCODE CSV RECORD FUNCTION
-------------------------------------------------------------------------*/
impl Record::genCSVRecordFuncC {
	cFile << endl <<
		%F%1/* Function that encodes a binary empty record. Parameters */
%f%0		%F%1/* and return values are the same of 'csvWriteSeparator */
%f%0		%F%1int encodeCSVRecord_%0«recordId»%1 (unsigned lineNo, char separator, WriteBinaryFunc writeBinaryFunc, void* writeBinaryFuncParameter, const T_%0«recordId»%1* record, char** errorMessage)
%f%0		%F%1{
%f%0		%F%1	int ret;
%f%0		%F%1	NOWARN_UNUSED(lineNo);
%f%0		%F%1	NOWARN_UNUSED(separator);
%f%0		%F%1	NOWARN_UNUSED(errorMessage);
%f%0		%F%1	%0
	;%f
%F
	cFile.incIndent ();%f
%F	%fvar Int i;
%F	%ffor (i=0; i<fields.count(); i++) {
%F	%f	if (i > 0) {
%F		%f	cFile << endl <<
				%F%1/* Write field %0«fields.get(i).fieldId»%1 */
%f%0				%F%1ret = csvWriteSeparator (separator, writeBinaryFunc, writeBinaryFuncParameter);
%f%0				%F%1if (ret != CSVRET_OK) return ret;
%0		%f	;
%F		%f}
%F		%ffields.get(i).genCSVRecordFuncC(cFile, i);
%F	%f}
%F	%f
%F	cFile.decIndent ();%f
%F	%fcFile <<
		%F%1	ret = csvWriteEndOfLine (writeBinaryFunc, writeBinaryFuncParameter);
%f%0		%F%1	return ret;
%f%0		%F%1}
%f%0	;
}

/*-------------------------------------------------------------------------
	GENERATE THE ENCODE CSV RECORD FUNCTION - NUMERIC FIELD
-------------------------------------------------------------------------*/
impl FieldTypeNumeric::genCSVRecordFuncC {
	var Int reps = upscan(Field).repetitions.value;
	var String idx;
	if (reps > 1) {
		idx = "[kk]";
		cFile << %F
%f		%F	%1{
%f%0			%F%1	unsigned kk;
%f%0			%F%1	for (kk=0; kk<%0«reps»%1; kk++) {
%f%0			%F%1		if (kk > 0) {
%f%0			%F%1			ret = csvWriteSeparator (separator, writeBinaryFunc, writeBinaryFuncParameter);
%f%0			%F%1			if (ret != CSVRET_OK) return ret;
%f%0			%F%1		}
%f%0		;
		cFile.incIndent();
		cFile.incIndent();
	}
	var String func;
	var String amp;
	if (boundTableLink.valid ()) {
		func = boundTableLink.keyField.fieldType.getCsvWriteReferenceField ();
		amp = "&";
	}
	else {
		func = "md380_CsvWriteNumericField";
	}
	cFile << %F
%f		%F%1ret = %0«func»%1 (DESC_%0«upscan(Record).recordId»%1+%0«fieldNum»%1, %0«amp»%1record->%0«upscan(Field).fieldId<<idx»%1, "%0«upscan(Record).recordId»%1", lineNo, writeBinaryFunc, writeBinaryFuncParameter, errorMessage);
%f%0		%F%1if (ret != CSVRET_OK) return ret;
%f%0	;
	if (reps > 1) {
		idx = "[kk]";
		cFile.decIndent();
		cFile.decIndent();
		cFile << %F
%f			%F%1	}
%f%0			%F%1}
%f%0		%F;%f
	}
}

/*-------------------------------------------------------------------------
	GENERATE THE ENCODE CSV RECORD FUNCTION - UNICODE FIELD
-------------------------------------------------------------------------*/
impl FieldTypeUnicode::genCSVRecordFuncC {
	cFile << %F
%f	%F	%1ret = csvWriteTokenUnicode (record->%0«upscan(Field).fieldId»%1, writeBinaryFunc, writeBinaryFuncParameter);
%f%0		%F%1if (ret != CSVRET_OK) return ret;
%f%0	%F;%f
}