lifeset CORE;

phase generateResolve = 60;

in phase generateResolve {
	do {
		// Prepare the file names
		var FilePath cFileName;
		var FilePath hFileName;
		cFileName.parse (outputName.text+"_resolve");
		hFileName.parse (outputName.text+"_resolve");
		cFileName.replaceExtension ("c");
		hFileName.replaceExtension ("h");
		
		// Open the files
		var FileOutStream cFile (cFileName);
		var FileOutStream hFile (hFileName);
		system().msg << "Generating " << cFileName << endl;
		system().msg << "Generating " << hFileName << endl;

		// Write the headers
		cFile << %F
%f			%F%1/* Generated by Macrocoder - do not edit */
%f%0			%F%1#define _CRT_SECURE_NO_WARNINGS
%f%0			%F%1#include "%0«hFileName.%fgetTopNamePart ()%F»%1"
%f%0			%F%1#include <string.h>
%f%0			%F%1#include "binlib.h"
%f%0			%F%1#include "crc.h"
%f%0			%F%1#include <assert.h>
%f%0		;
		
		var String ifndefText = %FhFileName.%fgetTopNamePart ().convertToIdentifier ();
		hFile << %F
%f			%F%1/* Generated by Macrocoder - do not edit */
%f%0			%F%1#ifndef %0«ifndefText»%1
%f%0			%F%1#define %0«ifndefText»%1
%f%0			%F%1#include "%0«getInclude("")»%1"
%f%0			%F%1#include "%0«getInclude("_valid")»%1"
%f%0			%F%1#include "%0«getInclude("_tables")»%1"
%f%0			%F%1
%f%0			%F%1/* Resolve the references in a container. Resolves the references read from a CSV, */
%f%0			%F%1/* i.e. it translates the unresolvedCrc into a refLineNo within t_reference  */
%f%0			%F%1extern int resolveReferences(const MD380Tables* tab, TRDTFile* container, ReportErrorFunc reportErrorFunc, void* reportErrorParam);
%f%0			%F%1
%f%0			%F%1/* Binds the references in a container. Resolves the references read from a CSV, */
%f%0			%F%1/* i.e. given valid refLineNo within t_reference, it binds the related resolvedName */
%f%0			%F%1extern int bindReferences(TRDTFile* container, ReportErrorFunc reportErrorFunc, void* reportErrorParam);
%f%0		;
		generateResolveFunction (cFile);
		generateBindFunction (cFile);
		
		// Write the footers
		hFile << endl <<
			%F%1#endif
%f%0		%F;%f
	}
	
	shared Void generateResolveFunction (out TextStream cFile) const;
	shared Void generateBindFunction (out TextStream cFile) const;
}

extend class Record {
	in phase generateResolve {
		shared Void generateResolveFunction (out TextStream cFile) const;
		shared Void generateBindFunction (out TextStream cFile) const;
	}
}

extend class FieldType {
	in phase generateResolve {
		shared Void generateResolveFunction (out TextStream cFile, String rec, Int fieldPos) const {}
		shared Void generateBindFunction (out TextStream cFile, String rec, Int fieldPos) const {}
	}
	String getBindReferenceFunc () const {return "\n#error FieldType::getBindReferenceFunc\n";}
	String getReadFieldReference () const {return "\n#error FieldType::getReadFieldReference\n";}
	String getAddLookupTable () const {return "\n#error FieldType::getAddLookupTable\n";}
	String getCsvWriteReferenceField () const {return "\n#error FieldType::getCsvWriteReferenceField\n";}
}

extend class FieldTypeNumeric {
	in phase generateResolve {
		shared Void generateResolveFunction (out TextStream cFile, String rec, Int fieldPos) const;
		shared Void generateBindFunction (out TextStream cFile, String rec, Int fieldPos) const;
	}
	String getBindReferenceFunc () const {return "md380_BindReferenceNumeric";}
	String getReadFieldReference () const {return "md380_ReadFieldReferenceNumeric";}
	String getAddLookupTable () const {return "ADD_LookupTableNumeric";}
	String getCsvWriteReferenceField () const {return "md380_CsvWriteReferenceFieldNumeric";}
}

extend class FieldTypeUnicode {
	String getBindReferenceFunc () const {return "md380_BindReferenceUnicode";}
	String getReadFieldReference () const {return "md380_ReadFieldReferenceUnicode";}
	String getAddLookupTable () const {return "ADD_LookupTableUnicode";}
	String getCsvWriteReferenceField () const {return "md380_CsvWriteReferenceFieldUnicode";}
}

/*================================================================================
	GENERATE TOP LEVEL RESOLVE FUNCTION
================================================================================*/
impl generateResolveFunction {
	cFile <<
		%F%1/* Resolve the references in a container. Resolves the references read from a CSV, */
%f%0		%F%1/* i.e. it translates the unresolvedCrc into a refLineNo within t_reference  */
%f%0		%F%1int resolveReferences(const MD380Tables* tab, TRDTFile* container, ReportErrorFunc reportErrorFunc, void* reportErrorParam)
%f%0		%F%1{
%f%0		%F%1	int noOfViolations = 0;
%f%0		%F%1	unsigned i, j;
%f%0	%F;
%f	%Fvar Int i;
%f	%FcFile.%fincIndent ()%F;
%f	%Ffor (i=0; i<%frecordsMap%F.count (); i++) {
%f	%F	recordsMap.getAt(i).generateResolveFunction(cFile);
%f	%F}
%f	%FcFile.%fdecIndent ()%F;
%f	cFile <<
		%F%1
%f%0		%F%1	return noOfViolations;
%f%0		%F%1}
%f%0	%F;%f
}

/*================================================================================
	GENERATE RECORD RESOLVE FUNCTION
================================================================================*/
impl Record::generateResolveFunction {
	var Int i;
	var Int hasReferences = false;

	/* See if this record has references */
	for (i=0; i<fields.count(); i++) {
		if (fields.get(i).fieldType.isReference ()) {hasReferences=true;}
	}
	if (!hasReferences) {return;}
	
	cFile << endl << %F%1/* Resolve references for record %0«recordId»%1 */%0 << endl;%f
	var String rec;
	
	if (count.value >= 1) {
		rec = "container->"+recordId.text+"[i]";
		cFile <<
			%F%1for (i=0; i<container->%0«recordId»%1_COUNT; i++) {
%f%0		%F;%f
		cFile.incIndent();
	}
	else {
		rec = "container->"+recordId.text;
	}

	for (i=0; i<fields.count(); i++) {
		fields.get(i).fieldType.generateResolveFunction (cFile, rec, i);
	}


	if (count.value >= 1) {
		cFile.decIndent();
		cFile <<
			%F%1}
%f%0		%F;%f
	}
}

/*================================================================================
	GENERATE RECORD RESOLVE FUNCTION
================================================================================*/
impl FieldTypeNumeric::generateResolveFunction {
	if (!boundTableLink.valid()) {return;}
	var String fieldId = upscan(Field).fieldId.text;
	var Int rep = upscan(Field).repetitions.value;
	var String recId = upscan(Record).recordId.text;
	var String fld;
	if (rep >= 1) {
		cFile << %F
%f		%F	%1for (j=0; j<%0«rep»%1; j++) {
%f%0		%F;%f
		fld = rec+"."+fieldId+"[j]";
		cFile.incIndent ();
	}
	else {
		fld = rec+"."+fieldId;
	}
	cFile <<
%F		%1/* RESOLVE FIELD %0«fieldId»%1 */
%0		%1if (md380_ResolveReference (DESC_%0«recId»%1+%0«fieldPos»%1, &%0«fld»%1, &tab->TAB_%0«boundTableLink.%frecordId%F»%1, "%0«recId»%1", i, "%0«fieldId»%1", "%0«boundTableLink.%frecordId%F»%1", reportErrorFunc, reportErrorParam)) noOfViolations++;
%0	;%f

	if (rep >= 1) {
		cFile.decIndent ();
		cFile << %F
%f		%F	%1}
%f%0		%F;%f
	}
}


/*================================================================================
	GENERATE TOP LEVEL BIND FUNCTION
================================================================================*/
impl generateBindFunction {
	cFile <<
		%F%1/* Binds the references in a container. Resolves the references read from a CSV, */
%f%0		%F%1/* i.e. given valid refLineNo within t_reference, it binds the related resolvedName */
%f%0		%F%1int bindReferences(TRDTFile* container, ReportErrorFunc reportErrorFunc, void* reportErrorParam)
%f%0		%F%1{
%f%0		%F%1	int noOfViolations = 0;
%f%0		%F%1	unsigned i, j;
%f%0	%F;
%f	%Fvar Int i;
%f	%FcFile.%fincIndent ()%F;
%f	%Ffor (i=0; i<%frecordsMap%F.count (); i++) {
%f	%F	recordsMap.getAt(i).generateBindFunction(cFile);
%f	%F}
%f	%FcFile.%fdecIndent ()%F;
%f	cFile <<
		%F%1
%f%0		%F%1	return noOfViolations;
%f%0		%F%1}
%f%0	%F;%f
}

/*================================================================================
	GENERATE RECORD BIND FUNCTION
================================================================================*/
impl Record::generateBindFunction {
	var Int i;
	var Int hasReferences = false;

	/* See if this record has references */
	for (i=0; i<fields.count(); i++) {
		if (fields.get(i).fieldType.isReference ()) {hasReferences=true;}
	}
	if (!hasReferences) {return;}
	
	cFile << endl << %F%1/* Bind references for record %0«recordId»%1 */%0 << endl;%f
	var String rec;
	
	if (count.value >= 1) {
		rec = "container->"+recordId.text+"[i]";
		cFile <<
			%F%1for (i=0; i<COUNT_%0«recordId»%1; i++) {
%f%0		%F;%f
		cFile.incIndent();
	}
	else {
		rec = "container->"+recordId.text;
	}

	for (i=0; i<fields.count(); i++) {
		fields.get(i).fieldType.generateBindFunction (cFile, rec, i);
	}


	if (count.value >= 1) {
		cFile.decIndent();
		cFile <<
			%F%1}
%f%0		%F;%f
	}
}

/*================================================================================
	GENERATE RECORD BIND FUNCTION
================================================================================*/
impl FieldTypeNumeric::generateBindFunction {
	if (!boundTableLink.valid()) {return;}
	var String fieldId = upscan(Field).fieldId.text;
	var Int rep = upscan(Field).repetitions.value;
	var String recId = upscan(Record).recordId.text;
	var String fld;
	if (rep >= 1) {
		cFile << %F
%f		%F	%1for (j=0; j<%0«rep»%1; j++) {
%f%0		%F;%f
		fld = rec+"."+fieldId+"[j]";
		cFile.incIndent ();
	}
	else {
		fld = rec+"."+fieldId;
	}
	cFile <<
%F		%1/* BIND FIELD %0«fieldId»%1 */
%0		%1if (%0«boundTableLink.%fkeyField%F.fieldType.getBindReferenceFunc()»%1 (DESC_%0«recId»%1+%0«fieldPos»%1, &%0«fld»%1, container->%0«boundTableLink.%frecordId%F»%1_COUNT, container->%0«boundTableLink.%frecordId%F»%1[(%0«fld»%1.refLineNo > 0) ? %0«fld»%1.refLineNo-1 : 0].%0«boundTableLink.%fkeyField%F.fieldId»%1, "%0«recId»%1", i, "%0«fieldId»%1", "%0«boundTableLink.%frecordId%F»%1", reportErrorFunc, reportErrorParam)) noOfViolations++;
%0	;%f

	if (rep >= 1) {
		cFile.decIndent ();
		cFile << %F
%f		%F	%1}
%f%0		%F;%f
	}
}